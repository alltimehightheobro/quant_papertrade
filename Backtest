import pandas as pd
import numpy as np
import matplotlib as mpl
mpl.rc('font', family = 'Malgun Gothic')
import matplotlib.pyplot as plt
import datetime
import math

import plotly.graph_objects as go
from plotly.subplots import make_subplots


# 리밸런싱 조건 설정해주기
# 리밸런싱 주기
rebalancing = 91 #일 단위

# 거래비용
tax = 0.0002 # 현재 거래비용은 0.02%입니다.

# 투자원금
cash = 100000000 # 모의투자 시작금액인 1억으로 시작하겠습니다.
money = cash

risk_free_rate = 0.0359 # 23년 4월 1일 기준 CD91일물 금리로 하겠습니다.

# 손절기준
loss_cut = 0.1 #매수 이후 10% 이상 가격이 떨어지면 매도하겠습니다.

day = 0
quarter = 0
df_list = '현금 주식총액 포트폴리오가치 일일수익률 총수익률'.split() # 백테스트 데이터프레임에 보여줄 항목들입니다. 이후에 더 추가할거에요
backtest = pd.DataFrame(columns = df_list)


#상장폐지된 주가 데이터까지 모두 받아오기 -> 편향을 제거하기 위해서입니다.

quick_ratio.drop(0, axis = 'columns', inplace=True) # 분기별 당좌비율 데이터입니다.
cashflow.drop(0, axis = 'columns', inplace=True) # 분기별 영업활동 현금흐름 데이터입니다.
# 두 데이터 역시 마찬가지로 상폐된 종목들 모두 다운로드 했습니다.

quick_ratio.columns = quick_ratio.iloc[0,:]
quick_ratio = quick_ratio.iloc[1:,:]
cashflow.columns = cashflow.iloc[0,:]
cashflow = cashflow.iloc[1:, :]
# 보기좋게 만들기

# 리밸런싱 주기와 데이터의 날짜가 맞지않을 경우 코드를 짜기 까다로우니 주의해주세요!!


print('전체 리밸런싱 횟수는 {}'.format(int(len(price_data)/rebalancing)))
for reb in range(int(len(price_data)/rebalancing)): #리밸런싱 횟수를 계산해줍니다. 전체 투자기간/리밸런싱 주기
    print( reb+1, '회 투자')
    print('현금 : ', money)
    inv = price_data.iloc[day:day+rebalancing,:] #전체 주가 데이터에서 투자기간동안의 데이터를 뽑아냅니다.
    inv = inv.replace(np.NaN, 0) # 수정주가 데이터에 없는 값들은 0으로 처리해줍니다.
    inv = inv.loc[:,inv.iloc[0,:] > 0 ] # 투자 시작 시점에 데이터가 0인 친구들은 다 날려줍니다.
    # 스크리닝


    quick_ratio_inv = pd.DataFrame(quick_ratio.iloc[quarter, :]) # 투자 시점의 데이터를 불러와줍니다.
    quick_ratio_inv = quick_ratio_inv.dropna(axis = 'index') # 투자 시점에 없는 데이터들은 제거해줍니다.
    quick_ratio_inv = quick_ratio_inv.sort_values(by = quick_ratio_inv.columns[0], ascending = False) # 내림차순으로 정렬해주고
    quick_ratio_inv = quick_ratio_inv[quick_ratio_inv[quick_ratio_inv.columns[0]] > 100] # 당좌비율이 100 이상인 기업들만 남깁니다.
    quick_ratio_inv_list = quick_ratio_inv.index # 리스트로 저장해줍니다.



    cashflow_inv = pd.DataFrame(cashflow.iloc[quarter, :])
    cashflow_inv.dropna(axis = 'index', inplace = True) # NaN값 제거해주고
    cashflow_inv = cashflow_inv.sort_values(by = cashflow_inv.columns[0], ascending=False) # 내림차순으로 정렬하겠습니다.
    cashflow_inv = cashflow_inv[cashflow_inv.iloc[:,0] > 0] # 영업활동 현금흐름이 0이상인 기업만 추려줍니다.
    cashflow_inv_list = cashflow_inv.index #리스트로 저장해줍니다.


    eps_inv = eps.iloc[day : day+rebalancing, :] # 투자 기간동안의 데이터를 불러와줍니다
    eps_inv = eps_inv.replace(np.NaN, 0)
    eps_inv = eps_inv.loc[:,eps_inv.iloc[0,:] > 0 ] # eps가 0 이상인 기업들만 골라줍니다.

    constraint = quick_ratio_inv_list.intersection(cashflow_inv_list) # 두 조건 모두에 걸리는 종목들을 선정해줍니다
    constraint = constraint.intersection(eps_inv.columns) # 다시 eps와 조건에 맞게 선정해줍니다

    inv_list = eps_inv[constraint].iloc[0,:].sort_values(ascending = False)[:20].index

    print('투자 후보 갯수는 : ', len(inv_list))

    #여기까지 스크리닝 과정입니다.

    final_inv_list = []
    for i in range(len(inv_list)):
        if inv_list[i] in inv.columns:
            final_inv_list.append(inv_list[i])
        else:
            print(inv_list[i],' 종목이 없습니다')
    print('투자하는 종목의 수는 : ', len(final_inv_list))
    print('투자종목 : ',final_inv_list)
    # 스크리닝 된 종목 들 중 가격 데이터에 있는 종목들만 투자 리스트에 추가해줍니다.


    # 매수 기준 : 동일 비중
    # 보유한 주식의 가치 평가하기

    if len(final_inv_list)==0:
        allocation=0
    else:
        allocation = money / len(final_inv_list) # 동일 비중이기 때문에 보유 현금 / 투자할 종목 수 로 나눠줍니다.


    print('동일 비중 투자 금액은 : ' , allocation) # 저는 제 코드를 믿지 못하기 때문에 이렇게 중간중간 어디서 에러가 나는지 예상할 수 있게 출력 결과도 함께 프린트합니다.
    final_price_data = inv[final_inv_list].copy()



    vec = pd.DataFrame({'매수수량' : allocation // final_price_data.iloc[0,:]}) # 종목당 매수할 수를 데이터프레임(벡터) 로 만들어줍니다.
    vec = vec.replace(np.NaN, 0)

    #매도(손절 기준) : 10% 이상 떨어질 경우 매도

    # 손절을 할 때 보유하고 있는 주식수를 0으로 만들거나
    # 손절 이후 포트폴리오의 가격을 0으로 만들거나의 방법을 선택할 수 있겠죠?
    # 저는 손절 한 순간부터 포트폴리오에서 주가를 계산하지 않아도 되는 방법이 더 편할 것 같아서 이렇게 선택했지만
    # 저와 다르게 계산하셔도 상관없습니다.
    loss_cut_money_list = []
    loss_cut_money = 0
    for days in final_price_data.index:
        for stocks in final_price_data.columns:
            if final_price_data.loc[days, stocks] < final_price_data[stocks][0] * ( 1 - loss_cut ):
                loss_cut_money = loss_cut_money + (final_price_data.loc[days, stocks] * float(vec.loc[stocks])) * (1 - tax)
                final_price_data.loc[days:, stocks] = 0

        loss_cut_money_list.append(loss_cut_money)


        # 날짜에 저장된 값을 리스트에 추가해줍니다. 이 반복문을 돌면서 포트폴리오 투자기간동안의 현금이 저장될 것입니다.



    product = np.dot(final_price_data, vec) #np.dot 통해 행렬과 벡터의 내적값을 구해줍니다.
    product = pd.DataFrame(product) #데이터프레임으로 만들어서 나중에 붙여주겠습니다.



    balance = pd.DataFrame(index = product.index)
    balance['현금'] = money - product.iloc[0,0] # 현금은 리밸런싱이 이루어지는 날의 현금에서 주식 매수대금을 뺀 값입니다.
    balance['현금'] += loss_cut_money_list # 손절한 금액은 날짜별로 더해줍시다


    _backtest = pd.DataFrame(columns = df_list) # 빈 데이터프레임을 만들어줍니다.
    _backtest['주식총액'] = product # 보유하고 있는 주식의 가치입니다.
    _backtest['현금'] = balance['현금'] # 아까 계산한 일자별 현금 데이터를 넣어줍니다.


    _backtest['포트폴리오가치'] = _backtest['현금'] + _backtest['주식총액'] # 포트폴리오 가치는 현금과 주식총액의 합입니다.
    _backtest['총수익률'] = (_backtest['포트폴리오가치']/cash) # 처음 들고 시작한 돈 대비 수익률
    _backtest.index = price_data.index[day : day + rebalancing]


    backtest = pd.concat([backtest, _backtest], axis = 0, ignore_index=False)
    # 데이터프레임들을 계속 붙여주면서 백테스트 데이터를 만들겠습니다.
    # 반복문을 돌면서 빈데이터프레임에 데이터를 채워가기 때문에 먼저 선언해준 백테스트 데이터프레임에 붙여줍니다.


    # 리밸런싱 이후 시작 금액은 주식 판매대금 - 거래비용 + 현금입니다.
    money = backtest.iloc[-1,0] + (backtest.iloc[-1,1] * ( 1 - tax))
    day = day + rebalancing
    quarter += 1

backtest['일일수익률'] = backtest['포트폴리오가치'].pct_change()

//Benchmark Data//

# CAGR : 연평균 성장률 ( Compound Annual Growth Rate)
num_of_year = int(len(backtest)/365)

CAGR = (backtest['포트폴리오가치'][-1]/cash)**(1/num_of_year) - 1
print('포트폴리오 CAGR은 {} %'.format(CAGR*100))

BENCHMARK_CAGR = ((BM['시가'][3911] / BM['시가'][0])) ** (1 / num_of_year) - 1
print("벤치마크 CAGR은 {} %".format(BENCHMARK_CAGR*100))


//Backtest data//

BENCHMARK_max_list = [BM.iloc[0,0]]
BENCHMARK_min_list = [BM.iloc[0,0]]

for i in range(len(BM)):
    if i==0:
        BENCHMARK_max_list.append(BM.iloc[0,0])
        BENCHMARK_min_list.append(BM.iloc[0,0])

    else:
        if BM.iloc[i, 2] >= BM.iloc[i-1,2]:
            BENCHMARK_max_list.append(BM.iloc[i, 0])
            BENCHMARK_min_list.append(BM.iloc[i, 0])
        else:
            if(BENCHMARK_max_list[-1]>BM.iloc[:i,2].max()):
                BENCHMARK_max_list.append(BENCHMARK_max_list[-1])
            else:
                BENCHMARK_max_list.append(backtest.iloc[:i,2].max())
            BENCHMARK_min_list.append(BM.iloc[i, 0])


BENCHMARK_max_list = BENCHMARK_max_list[1:]
BENCHMARK_min_list = BENCHMARK_min_list[1:]
BM['max'] = BENCHMARK_max_list
BM['min'] = BENCHMARK_min_list
BM['mdd'] = -((BM['max'] - BM['min'])/BM['max'])

print('BENCHMARK MDD는 {}%'.format(BM['mdd'].min()*100))

BM['MDD'] = 0
for i in range(len(BM)):
    if i != 0:
        BM.iloc[i, -1] = BM['mdd'][:i].min()


# Sharpe Ratio = (자산 X의 기대수익률 – 무위험 자산 수익률) / 자산 X의 기대수익률의 표준편차
backtest_return = backtest['일일수익률'].mean()
backtest_std = backtest['일일수익률'].std()

BM_return = BM['일일수익률'].mean()
BM_std = BM['일일수익률'].std()

backtest_sharpe = (backtest_return - risk_free_rate) / backtest_std
BM_sharpe = (BM_return - risk_free_rate) / BM_std

print('BACKTEST 샤프 비율은 : ', backtest_sharpe)
print('BENCHMARK 샤프 비율은 : ', BM_sharpe)



fig = make_subplots(rows=4, cols=1,
                    specs=[[{"rowspan":3}],
                          [None],
                          [None],
                          [{}]],
                   shared_xaxes=True,
                   vertical_spacing=0.2,
                   subplot_titles=("수익률","MDD"))

fig.add_trace(go.Scatter(name='코스피 총수익률', x=BM.index, y=BM['총수익률']),
             row=1, col=1)
fig.add_trace(go.Scatter(name='포트폴리오 총수익률', x=backtest.index, y=backtest['총수익률']),
             row=1, col=1)
fig.add_trace(go.Scatter(name='포트폴리오 MDD', x=backtest.index, y=backtest['MDD'], fill='tozeroy'),
             row=4, col=1)
fig.add_trace(go.Scatter(name='BENCHMARK MDD', x=BM.index, y=BM['MDD'], fill='tozeroy'),
             row=4, col=1)

fig.update_layout(height=800, width=1000, plot_bgcolor='rgb(240, 240,240)',
                 title_text="백테스트 결과")

fig.update_layout(
    xaxis=dict(
        rangeselector=dict(
            buttons=list([
                dict(count=1,
                     label="1m",
                     step="month",
                     stepmode="backward"),
                dict(count=6,
                     label="6m",
                     step="month",
                     stepmode="backward"),
                dict(count=1,
                     label="YTD",
                     step="year",
                     stepmode="todate"),
                dict(count=1,
                     label="1y",
                     step="year",
                     stepmode="backward"),
                dict(step="all")
            ])
        ),
        rangeslider=dict(
            visible=True
        ),
        type="date"
    )
)

fig.show()



//Fin
